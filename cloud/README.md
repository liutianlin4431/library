**cloud-api-commons:微服务公共模块**

```tex
eureka：基本搭建

	cloud-provider-payment8001/cloud-provider-payment8001:（集群）eureka客户端-微服务提供支付模块 

	cloud-consumer-order80:eureka客户端-微服务消费支付模块 

	cloud-eureka-server7001/cloud-eureka-server7002：(集群)eureka注册中心
	
	cloud-consumer-feign-order80：使用openfeign调用HTTP接口
```



------

**什么是服务治理？**

> 在传统的rpc远程调用框架中，管理每个服务于服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理费服务于服务之间依赖关系，可以实现服务调用，负载均衡，容错等，实现服务发现注册

------

**什么是服务注册？**

> 在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息（比如服务器通信地址等）以别名方式注册到服务中心上。另一方（消费者|服务器提供者），以该别名的方式去注册中心上获取到实际的服务通信地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何RPC远程框架中，都会有一个注册中心存放服务器地址相关信息

------

**Eureka包含两个组件：Eureka Server和Eureka Clinet**

> Eureka Server提供服务注册服务
>
> 各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中讲将会存储所有可用的服务节点的信息，服务节点的信息可以在见面中直观看到。

> Eureka Clinet通过注册中心进行访问
>
> 是一个java客户端，用户简化Eureka Server的交互，客户端同事也具备一个内置的、使用轮询（round-robin）负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳（默认周期30秒）。如果Eureka Server在多个心跳中期内没有接收到某个节点的细条，Eureka Server将会从服务注册表中把这个服务节点移除（默认90秒）

------

**Eureka自我保护记住**

> 为什么产生？
>
> 为了防止Eureka Client 可以正常运行，但是与Eureka Server 网络不通的情况下，Eureka Server **不会立刻**将 Eureka Client 服务剔除

> 什么是自我保护？
>
> 默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server 将会注销该实例（默认90秒）。但是当前网络分区故障发生（延时、卡顿、拥挤）时，微服务与Eureka Server 之间无法正常通信，以上行为可能变得非常危险—**因为微服务本身是健康的，此时本不应该注销这个微服务**。Eureka 通过自“自我保护模式”来解决这个问题—当Eureka Server 节点在短时间内丢失过多客户端时（可能发生网络分区故障），那么这个节点就会进入自我保护。

------

**Spring Cloud Ribbon是基于Netflix Ribbon实现得一套客户端负载均衡工具**

> 简单的说，Ribbon是Netflix发布得开源项目，**主要功能是提供客户端的软件负载均衡算法和服务调用**。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动给的帮助你基于某种规则（如简单轮询，随即链接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。

------

**LB负载均衡（Load Balance）是什么？**

> 简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）
>
> 常见的负载均衡有软件Nginx,LVS，硬件F5等。

------

**Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别**

> Nginx是服务器负载均衡，客户端所有请求夺回交给Nginx，然后由Nginx实现转发请求。既负载均衡由服务器端实现。
>
> Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。

------

**Feign能干什么**

> Feign旨在使用编写Java Http客户端变得更容易。
>
> 前面在使用Ribbon+RestTemplate时，立用了RestTemplate对HTTP请求的封装处理，形成了一套模板化方法。**但是实际开发中，由于服务以来的调用可能不止一处，往往一个接口会被多处调用，所以通常会针对每个微服务自行封装宜些客户端类来包装这些以来的服务的调用。**所以Feign在此基础上做了进一步封装，由它来帮助我们定义和实现依赖服务的定义。在Feign的实现下，**我们只需要创建一个即接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可）**，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自行封装服务调用客户端的开发量。

------

**Feign继承了Ribbon**

> 立用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。